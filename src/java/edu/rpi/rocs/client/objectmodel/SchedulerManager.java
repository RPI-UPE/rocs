package edu.rpi.rocs.client.objectmodel;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import com.google.gwt.event.shared.EventHandler;
import com.google.gwt.user.client.rpc.AsyncCallback;

import edu.rpi.rocs.client.services.schedulemanager.ScheduleManagerService;

/**
 * The Schedule Manager is responsible for keeping track of the current state of the scheduler on the
 * client side and for interfacing with the ScheduleManagerService to update the server and store
 * and retrieve schedules from the SQL database. 
 * 
 * @author ewpatton
 *
 */
public class SchedulerManager implements Serializable {

	/**
	 * The unique identifier for serialization
	 */
	private static final long serialVersionUID = 2193647582216874345L;
	/**
	 * Schedules generated by the scheduler
	 */
	private ArrayList<Schedule> generatedSchedules=null;
	/**
	 * The schedule currently selected by the user
	 */
	private Schedule currentSchedule=null;

	/**
	 * This is a helper class which stores whether a course is required or optional for inclusion
	 * in generated schedules.
	 * 
	 * @author ewpatton
	 *
	 */
	public class CourseStatusObject {
		/**
		 * The course to store status about
		 */
		private Course theCourse;
		/**
		 * Flag for whether a course is required or not
		 */
		private boolean isRequired;
		
		/**
		 * Creates a course status given a course and whether it is required
		 * @param c The course to store
		 * @param required Whether the course is required
		 */
		public CourseStatusObject(Course c, boolean required) {
			theCourse = c;
			isRequired = required;
			getCourse();
		}
		
		/**
		 * Sets the requirement flag
		 * @param required true if required, false if optional
		 */
		public void setRequired(boolean required) {
			isRequired = required;
		}
		
		/**
		 * Gets the requirement flag
		 * @return The requirement flag
		 */
		public boolean getRequired() {
			return isRequired;
		}
		
		/**
		 * Gets the course we're storing status of
		 * @return The course
		 */
		public Course getCourse() {
			return theCourse;
		}
	}
	
	/**
	 * The current set of courses for this session.
	 */
	private HashMap<Course, CourseStatusObject> currentCourses = new HashMap<Course, CourseStatusObject>();
	
	/**
	 * The ScheduleManager instance
	 */
	private static SchedulerManager theInstance;
	
	/**
	 * Listeners for when a course is added
	 */
	private HashSet<CourseAddedHandler> courseAddHandlers=new HashSet<CourseAddedHandler>();
	private HashSet<CourseRemovedHandler> courseRemoveHandlers=new HashSet<CourseRemovedHandler>();
	private HashSet<CourseRequiredHandler> courseRequiredHandlers=new HashSet<CourseRequiredHandler>();
	private HashSet<CourseOptionalHandler> courseOptionalHandlers=new HashSet<CourseOptionalHandler>();
	
	/**
	 * Hidden for singleton management
	 */
	private SchedulerManager() {
	
	}
	
	public List<CourseStatusObject> getSelectedCourses() {
		return new ArrayList<CourseStatusObject>(currentCourses.values());
	}
	
	public void addCourseAddedEventHandler(CourseAddedHandler e) {
		courseAddHandlers.add(e);
	}
	
	public void removeCourseAddedEventHandler(CourseAddedHandler e) {
		courseAddHandlers.remove(e);
	}
	
	public void addCourseRemovedEventHandler(CourseRemovedHandler e) {
		courseRemoveHandlers.add(e);
	}
	
	public void removeCourseRemovedEventHandler(CourseRemovedHandler e) {
		courseRemoveHandlers.remove(e);
	}
	
	public void addCourseRequiredEventHandler(CourseRequiredHandler e) {
		courseRequiredHandlers.add(e);
	}
	
	public void removeCourseRequiredEventHandler(CourseRequiredHandler e) {
		courseRequiredHandlers.remove(e);
	}
	
	public void addCourseOptionalEventHandler(CourseOptionalHandler e) {
		courseOptionalHandlers.add(e);
	}
	
	public void removeCourseOptionalEventHandler(CourseOptionalHandler e) {
		courseOptionalHandlers.remove(e);
	}
	
	/**
	 * Gets the singleton ScheduleManager instance
	 * @return The ScheduleManager
	 */
	public static SchedulerManager get() {
		if(theInstance==null) theInstance = new SchedulerManager();
		return theInstance;
	}
	
	/**
	 * Gets the list of saved schedules from the server.
	 * @param callback The AsyncCallback to call after the list has been retrieved
	 */
	public void getScheduleList(AsyncCallback<List<String>> callback) {
		ScheduleManagerService.Singleton.getInstance().getScheduleList(callback);
	}
	
	public interface CourseModificationHandler extends EventHandler {
		public void handleEvent(CourseStatusObject status);
	}
	
	public interface CourseAddedHandler extends CourseModificationHandler {
	}
	
	public interface CourseRemovedHandler extends CourseModificationHandler {
	}
	
	public interface CourseRequiredHandler extends CourseModificationHandler {
	}
	
	public interface CourseOptionalHandler extends CourseModificationHandler {
	}
	
	/**
	 * Adds a course to the current course listing
	 * @param c The course to add
	 */
	public void addCourse(Course c) {
		CourseStatusObject status =new CourseStatusObject(c, true); 
		currentCourses.put(c, status);
		for(CourseAddedHandler e : courseAddHandlers) {
			e.handleEvent(status);
		}
	}
	
	/**
	 * Sets  a course to be required to appear for a valid schedule
	 * @param c The course to make required
	 */
	public void setCourseRequired(Course c) {
		CourseStatusObject obj = currentCourses.get(c);
		if(obj!=null) {
			obj.setRequired(true);
			for(CourseRequiredHandler e : courseRequiredHandlers) {
				e.handleEvent(obj);
			}
		}
	}
	
	/**
	 * Sets a course to be optional to appear for a valid schedule
	 * @param c The course to make optional
	 */
	public void setCourseOptional(Course c) {
		CourseStatusObject obj = currentCourses.get(c);
		if(obj!=null) {
			obj.setRequired(false);
			for(CourseOptionalHandler e : courseOptionalHandlers) {
				e.handleEvent(obj);
			}
		}
	}
	
	/**
	 * Returns whether a course is required for a schedule
	 * @param c The course to check
	 * @return Whether the course is required or not
	 */
	public boolean isCourseRequired(Course c) {
		CourseStatusObject obj = currentCourses.get(c);
		if(obj!=null) {
			return obj.getRequired();
		}
		return false;
	}
	
	/**
	 * Removes a course from the user's list of courses
	 * @param c The course to remove
	 */
	public void removeCourse(Course c) {
		CourseStatusObject status = currentCourses.get(c);
		currentCourses.remove(c);
		for(CourseRemovedHandler e : courseRemoveHandlers) {
			e.handleEvent(status);
		}
	}
	
	/**
	 * Generates a new schedule session and clears any state information from the last session
	 */
	public void newSchedule() {
		currentCourses.clear();
		currentSchedule=null;
		generatedSchedules=null;
	}
	
	/**
	 * Returns the current Schedule selected by the user.
	 * @return
	 */
	public Schedule getCurrentSchedule() {
		return currentSchedule;
	}
	
	/**
	 * Returns all of the valid schedules computed by the scheduler.
	 * @return An ArrayList of valid schedules.
	 */
	public ArrayList<Schedule> getAllSchedules() {
		return generatedSchedules;
	}
	
	/**
	 * Saves the current Schedule to the server.
	 * @param name The name to give the schedule for later reference.
	 */
	public void saveCurrentSchedule(String name) {
		ScheduleManagerService.Singleton.getInstance().saveSchedule(name, currentSchedule, new AsyncCallback<Void>() {

			public void onFailure(Throwable caught) {
				// TODO Auto-generated method stub
				
			}

			public void onSuccess(Void result) {
				// TODO Auto-generated method stub
				
			}
			
		});
	}
}
